"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortRectanglesByHilbertCoordinates = void 0;
const HilbertCurves_js_1 = require("../hilbert/HilbertCurves.js");
function sortRectanglesByHilbertCoordinates(rectangles) {
    // We shall create a square sized coordinate system with height = width. The
    // square must encapsulate all rectangles in the tree. To determine the required
    // size of the square, we must identify the max/min coordinates of the encapsulated
    // rectangles.
    const { maxCoordinate, minCoordinate } = rectangles
        .map(rectangle => [
        // X coordinate
        Math.ceil(rectangle.x + rectangle.width * 0.5),
        // Y coordinate
        Math.ceil(rectangle.y + rectangle.height * 0.5)
    ])
        .reduce(({ maxCoordinate: accumulatedMax, minCoordinate: accumulatedMin }, [x, y]) => {
        return {
            maxCoordinate: Math.max(accumulatedMax, Math.max(x, y)),
            minCoordinate: Math.min(accumulatedMin, Math.min(x, y))
        };
    }, { maxCoordinate: -Infinity, minCoordinate: Infinity });
    const weightedRectangles = rectangles
        .map(rectangle => ({
        rectangle,
        weight: (0, HilbertCurves_js_1.toHilbertCoordinates)(maxCoordinate - minCoordinate, Math.ceil(rectangle.x + rectangle.width * 0.5) - minCoordinate, Math.ceil(rectangle.y + rectangle.height * 0.5) - minCoordinate)
    }));
    weightedRectangles.sort((A, B) => A.weight - B.weight);
    return weightedRectangles.map(({ rectangle }) => rectangle);
}
exports.sortRectanglesByHilbertCoordinates = sortRectanglesByHilbertCoordinates;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydFJlY3RhbmdsZXNCeUhpbGJlcnRDb29yZGluYXRlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9taXNjL3NvcnRSZWN0YW5nbGVzQnlIaWxiZXJ0Q29vcmRpbmF0ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsa0VBQW1FO0FBR25FLFNBQWdCLGtDQUFrQyxDQUFDLFVBQWlDO0lBQ2xGLDRFQUE0RTtJQUM1RSxnRkFBZ0Y7SUFDaEYsbUZBQW1GO0lBQ25GLGNBQWM7SUFDZCxNQUFNLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxHQUFHLFVBQVU7U0FDaEQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7UUFDaEIsZUFBZTtRQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUM5QyxlQUFlO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0tBQ2hELENBQUM7U0FDRCxNQUFNLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDbkYsT0FBTztZQUNMLGFBQWEsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN2RCxhQUFhLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDeEQsQ0FBQztJQUNKLENBQUMsRUFBRSxFQUFFLGFBQWEsRUFBRSxDQUFDLFFBQVEsRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUU1RCxNQUFNLGtCQUFrQixHQUFHLFVBQVU7U0FDbEMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqQixTQUFTO1FBQ1QsTUFBTSxFQUFFLElBQUEsdUNBQW9CLEVBQzFCLGFBQWEsR0FBRyxhQUFhLEVBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLGFBQWEsRUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsYUFBYSxDQUNoRTtLQUNGLENBQUMsQ0FBQyxDQUFDO0lBRU4sa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFdkQsT0FBTyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBaENELGdGQWdDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvSGlsYmVydENvb3JkaW5hdGVzIH0gZnJvbSBcIi4uL2hpbGJlcnQvSGlsYmVydEN1cnZlcy5qc1wiO1xuaW1wb3J0IHR5cGUgeyBSVHJlZVJlY3RhbmdsZSB9IGZyb20gXCIuLi9yLXRyZWUvUlRyZWVSZWN0YW5nbGUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRSZWN0YW5nbGVzQnlIaWxiZXJ0Q29vcmRpbmF0ZXMocmVjdGFuZ2xlczogQXJyYXk8UlRyZWVSZWN0YW5nbGU+KTogQXJyYXk8UlRyZWVSZWN0YW5nbGU+IHtcbiAgLy8gV2Ugc2hhbGwgY3JlYXRlIGEgc3F1YXJlIHNpemVkIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggaGVpZ2h0ID0gd2lkdGguIFRoZVxuICAvLyBzcXVhcmUgbXVzdCBlbmNhcHN1bGF0ZSBhbGwgcmVjdGFuZ2xlcyBpbiB0aGUgdHJlZS4gVG8gZGV0ZXJtaW5lIHRoZSByZXF1aXJlZFxuICAvLyBzaXplIG9mIHRoZSBzcXVhcmUsIHdlIG11c3QgaWRlbnRpZnkgdGhlIG1heC9taW4gY29vcmRpbmF0ZXMgb2YgdGhlIGVuY2Fwc3VsYXRlZFxuICAvLyByZWN0YW5nbGVzLlxuICBjb25zdCB7IG1heENvb3JkaW5hdGUsIG1pbkNvb3JkaW5hdGUgfSA9IHJlY3RhbmdsZXNcbiAgICAubWFwKHJlY3RhbmdsZSA9PiBbXG4gICAgICAvLyBYIGNvb3JkaW5hdGVcbiAgICAgIE1hdGguY2VpbChyZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCAqIDAuNSksXG4gICAgICAvLyBZIGNvb3JkaW5hdGVcbiAgICAgIE1hdGguY2VpbChyZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQgKiAwLjUpXG4gICAgXSlcbiAgICAucmVkdWNlKCh7IG1heENvb3JkaW5hdGU6IGFjY3VtdWxhdGVkTWF4LCBtaW5Db29yZGluYXRlOiBhY2N1bXVsYXRlZE1pbiB9LCBbeCwgeV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heENvb3JkaW5hdGU6IE1hdGgubWF4KGFjY3VtdWxhdGVkTWF4LCBNYXRoLm1heCh4LCB5KSksXG4gICAgICAgIG1pbkNvb3JkaW5hdGU6IE1hdGgubWluKGFjY3VtdWxhdGVkTWluLCBNYXRoLm1pbih4LCB5KSlcbiAgICAgIH07XG4gICAgfSwgeyBtYXhDb29yZGluYXRlOiAtSW5maW5pdHksIG1pbkNvb3JkaW5hdGU6IEluZmluaXR5IH0pO1xuXG4gIGNvbnN0IHdlaWdodGVkUmVjdGFuZ2xlcyA9IHJlY3RhbmdsZXNcbiAgICAubWFwKHJlY3RhbmdsZSA9PiAoe1xuICAgICAgcmVjdGFuZ2xlLFxuICAgICAgd2VpZ2h0OiB0b0hpbGJlcnRDb29yZGluYXRlcyhcbiAgICAgICAgbWF4Q29vcmRpbmF0ZSAtIG1pbkNvb3JkaW5hdGUsXG4gICAgICAgIE1hdGguY2VpbChyZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCAqIDAuNSkgLSBtaW5Db29yZGluYXRlLFxuICAgICAgICBNYXRoLmNlaWwocmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0ICogMC41KSAtIG1pbkNvb3JkaW5hdGVcbiAgICAgIClcbiAgICB9KSk7XG5cbiAgd2VpZ2h0ZWRSZWN0YW5nbGVzLnNvcnQoKEEsIEIpID0+IEEud2VpZ2h0IC0gQi53ZWlnaHQpO1xuXG4gIHJldHVybiB3ZWlnaHRlZFJlY3RhbmdsZXMubWFwKCh7IHJlY3RhbmdsZSB9KSA9PiByZWN0YW5nbGUpO1xufVxuIl19